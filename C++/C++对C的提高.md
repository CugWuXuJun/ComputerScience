##C++基础知识点总结
* [面相对象的基本概念](#面相对象的基本概念)  
  * [面相对象](#面相对象)
  * [类](#类)
  * [封装](#封装)  
  
* [C++命名空间](#C++命名空间)  
* [register](#register)
* [三目运算符](#三目运算符)
* [const](#const)
* [引用专题](#引用专题)
* [inline内联函数](#inline内联函数)

###面相对象的基本概念
####面相对象
在面试过程中，有两次面试被问及谈谈你对面相对象的理解这个问题，那么面试官到底想问什么呢？谈面相对象，我们就要了解什么是对象，一般意义上的对象指的是现实世界上客观存在的事物，可以是可见的，也可以是不可见的，如人，书籍、空气、计划等等。他是构成世界的一个独立单位，具有两个维度的特征，一个是静态特征，可以用数据来描述，一个动态特征，对象表现出来的行为或者具有的功能。

而面相对象方法中的对象是用来描述客观事物的一个实体，它是用来构成系统的一个基本单位。像现实世界上的对象一样，面相方法中的对象也是由一组属性和一组行为，属性，用来描述对象静态特征的数据项，行为，就是描述对象动态特征的行动序列。
####类
所谓的类，也就即分类。分类的原则就是抽象。忽略事物的非本质特征，只注意那些与当前目标有关的本质特征，从而找出事物的共性，把具有共同性质的事物划分为一类，得出一个抽象的概念。在面相对象方法中的类指的是具有相同属性和行为的一组对象的集合，属于该类的全部对象提供了抽象的描述，包括属性和行为两个主要部分。一个类的对象称为对象的实例。
####封装
所谓的封装就是将客观事物封装成为抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象进行操作，对不可信的进行信息隐藏。其包含

两个方面的含义：

一个是把对象的属性和服务结合成为一个独立的系统单元。

一个是隐蔽对象的内部细节，对外部形成一个边界，只保留有限的接口与外界发生联系。
				
###C++命名空间
在c语言中，只有一个全局作用域，那么c语言中的所有标识符共享同一个作用域，标志符的冲突的可能性很大。

C++中提出了命名空间的概念，命名空间将全局作用域分成了不同部分，不同命名空间中的标识符可以同名而不发生冲突，命名空间也可以嵌套。全局作用域也叫默认命名空间。  
命名空间的冲突

```c++
#include <iostream>
using namespace std;
int count = 0;
int main(int argc, const char * argv[]) {
    // insert code here...
    ::cout << "Hello, World!\n";
    cout << count<<endl;
    return 0;
}
```
注：产生冲突的原因，在namespace命名空间中存在一个叫做count的函数名，没有加域名限定符的话，系统无法确定调用那一个测试。正确做法:`cout<<::count<<endl;`.

```c++
using namespace std;
class compareFun {
public:
    bool operator()(const string& string1, const string& string2) {
        string temp1;
        string temp2;
        temp1.resize(string1.size());
        temp2.resize(string2.size());
        transform(string1.begin(),string1.end(),temp1.begin(),::tolower);
        transform(string2.begin(),string2.end(),temp2.begin(),::tolower);
        return temp1<temp2;
    }
};
```
注:`::tolower`就是限定这个函数要在全局命名空间中找这个函数。
###register
register关键字 请求编译器让变量a直接放到寄存器里面，这样速度比较快。

在C语言中，register修饰的变量不能获取地址，c++中，能够获取变量的地址，这个时候会使得register关键字失效。同时，编译器也能够自己做优化，不使用registr关键字同样能够使得变量直接放到寄存器中。
		
###三目运算符
####c++中的三目运算符可以做为左值。

```c++
#include <iostream>
using namespace std;
int count = 0;
int main(int argc, const char * argv[]) {
    // insert code here...
    cout << "Hello, World!\n";
    int a = 10, b= 100;
    (a < b ?  a : b) +=b;
    cout<< a<<endl;
}
```
###const
```c++
const int c = 0;//申明一个常量
const int *d  =NULL;//声明一个常量指针
int *const e = NULL;//声明一个指针常量
const int * const f = &c;//声明一个指向常量类型的指针常量
class Const_Example{
public:
    Const_Example(int index, int value){
        this->index = index;
        this->value = value;
    }
    //const保证传入的参数不被修改
    Const_Example(const Const_Example &e){
        this->index = e.index;
        this->value = e.value;
    }
     int getValue() const{
        return value;
    }
    const int getIndex() {
        return index;
    }
    //Const_Example * const this ;这个指针指向的内存空间可以被修改，但是这个指针变量的值不能被修改。
    void changeObject1(const Const_Example &e){
        Const_Example c = e;
        e = *this;
        *this = c;
    }
    // const Const_Example * const this ; 既不能改变指针指向的内存空间，也不能改变指针变量的值。
    void changeObject2(Const_Example &e) const{        
    Const_Example c = e;
        e = *this;
        *this = c;//error  No Viable overloaded `=`
    }
private:
    int index;
    int value;
};
```
	注：不被放在成员函数后面的const修饰的成员函数可以调用用const修饰的成员函数。但是被const修饰的成员函数却不能调用非const修饰的
	成员函数，因为指针类型不一致，在被调用函数的内部可能发生对象的修改，这个是const修饰的成员函数的初衷是矛盾的。

####c++编译器对const常量的处理
当碰见常量声明的时候，在符号表中放入常量。（符号表是使用键值对的方式存储）编译过程中如果发现使用常量则直接以符号表中的值进行替换。若都在编译过程中发现对const使用了extern或者&操作，则分配内存空间。

```c++
 int & a = 10;// Error
 int const &b = 10;//Ok
```
####const总结
C语言中的const变量是只读变量，有自己的存储空间。
C++中的const变量有自己的存储空间，也可能没有自己的存储空间

1.当const常量味全局，并且需要在其他文件中使用的时候，会分配存储空间。

2.当使用&操作符，取得const常量的地址的时候，会分配存储空间。

3.当const int &a = 10 const修饰引用，也会分配存储空间。

###引用专题
####变量名的回顾
变量名实际上是一段连续空间的别名，在程序中通过变量申请病命名内存空间。通过变量名来使用存储空间。

那么引用实际上也是对已经有的内存空间取另外一个别名。一般情况下，引用在声明的时候，就需要说明引用的对象。（当引用做形式参数除外）
####引用的意义
1、引用作为其他变量的别名而存在，因此在一些场合可以替代指针

2、引用相对于指针来说具有更好的可读性和实用性。

####引用的本质
引用的本质是一个指针常量`type& name --> type * const name`;因此引用类型变量的大小为指针类型大小。

注：引用类型变量其实有自己的存储空间，这是C++为了实用性而做出的细节隐藏。

####函数返回值是引用
当函数返回值是引用的时候，若返回的是栈变量，那么不能成为其他引用的初始值，不能作为左值使用。

若返回静态变量或者全局变量，可以作为左值，也可以作为右值。
####指针引用
```c++
    int *c  = &a;
    int* &d = c;
    cout << c<<endl;//0x7fff5fbff6fc
    cout << d<<endl;//0x7fff5fbff6fc
```
指针引用同样是给指针起一个别名，相当于一个二级指针。

####常引用
```c++
int a = 100;
const int & b= 100;
b = 1000;//error 不能改变引用值
```
const引用让变量具有只读属性
使用字面值初始化const引用

```c++
const int & a = 19;//分配内存空间 
const int b = 100;//放入符号表中
```
const引用结论
1、普通引用等价于 type * const e; 指针常量;

2、const引用等价于const type * const e;

3、当使用字面值对const引用进行初始化的时候，c++编译器会为常量值分配空
间，并将引用名作为这段空间的别名。

4、使用字面量对const引用初始化后，将生成一个只读变量。

```c++
    int a = 10;
    int b = 10;
    const int & e = a;
    e = b;//Error
```
###inline内联函数
内敛函数是为了解决某些情况系统开销，代替宏代码片段而出现的。（替代宏代码片段就可以避免宏的副作用！）

####内联函数的使用
内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。
####内联函数的处理
C++可以将一个函数进行内联编译，被内联编译的函数叫做内联函数。C++编译器直接将函数体插入在函数调用的地方。
但是C++编译器不一定准许函数的内连请求。现代一些编译器能够自动进行优化，即使一些函数没有声明内敛。因此一些函数会被自动内联。有些编译器甚至支持强制内敛。
####与宏片段的比较
宏代码片段由预处理器进行简单的文本替换，不做语法检查。
####内联函数的限制
只能使用在小的平凡调用函数上。
1、内联函数不能存在任何形式的循环语句

2、不能存在过多的条件判断语句

3、函数体不能过于pangda

4、不能对函数进行取址操作。

内联函数相对于普通函数来说优势只是在于函数调用的压栈、跳转和返回开销，如果函数体的开销过大，那么内联将毫无意义。

####内联函数的缺点
1）来自内联函数的添加变量消耗额外的寄存器，如果要使用寄存器的变量数增加，则在内联函数之后，它们可能会在寄存器变量资源利用率上产生开销。这意味着当在函数调用点替换内联函数体时，函数使用的变量总数也会被插入。因此，用于变量的寄存器数量也将增加。因此，如果在函数内联变量数量大幅增加之后，它肯定会导致寄存器利用率的开销。


2）如果使用太多的内联函数，那么二进制可执行文件的大小将会很大，因为相同代码的重复。


3）太多的内联也会降低指令缓存命中率，从而降低从缓存内存到主内存的指令获取速度。


4）如果有人更改了内联函数中的代码，则内联函数可能会增加编译时间开销，因此必须重新编译所有调用位置，因为编译器需要再次替换所有代码以反映更改，否则它将继续使用旧功能。


5）内联函数可能对许多嵌入式系统没用。因为在嵌入式系统中，代码大小比速度更重要。


6）内联函数可能会导致颠簸，因为内联可能会增加二进制可执行文件的大小。内存中的颠簸会导致计算机性能下降。
