###[362. 滑动窗口的最大值](#https://www.lintcode.com/problem/sliding-window-maximum/description)
给出一个可能包含重复的整数数组，和一个大小为 k 的滑动窗口, 从左到右在数组中滑动这个窗口，找到数组中每个窗口内的最大值。  

样例
样例 1:

输入:
[1,2,7,7,8]
3
输出:
[7,7,8]

解释：
最开始，窗口的状态如下：`[|1, 2 ,7| ,7 , 8]`, 最大值为 `7`;
然后窗口向右移动一位：`[1, |2, 7, 7|, 8]`, 最大值为 `7`;
最后窗口再向右移动一位：`[1, 2, |7, 7, 8|]`, 最大值为 `8`.
样例 2:

输入:
[1,2,3,1,2,3]
5
输出:
[3,3]

解释:
最开始，窗口的状态如下： `[|1,2,3,1,2 | ,3]` , 最大值为`3`;
然后窗口向右移动一位.`[1, |2,3,1,2,3]`, 最大值为 `3`;
挑战
O(n)时间，O(k)的额外空间

####题目解析：这个题目的核心问题在于如何维持数组长度为k的数组的最大值，由于这个过程中涉及到的是元素进入和退出窗口，因此适合使用双向队列处理。那么我们如何维持这样一个双向队列呢。并且双向队列中存储的是当前的最大值呢。
####最开始状态下，队列中是没有元素的，因此，元素下标可以直接进入队列。在队列不为空的时候，当下一个元素到来的时候，我们需要进行以下处理。如果当前元素比栈顶元素要大，那么将当前队尾元素出栈，更新最大值。直到队尾元素的值不小于当前元素。再将当前元素的下标入栈。这意味着我们维持着一个从 `dq.back() - dq-front() +1`个窗口大小。接着如果这个差值大于窗口的大小，就将队头出队，那么我们取到的第一个元素就是当前窗口的最大值了。
```c++

/*
主要问题是如何获取当前区间的最大值，传统的方法是需要排序的，这个排序操作需要O（k）的代价
我们采用
*/
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int> nums, int k) {
       deque<int> dq ;
       vector<int> r;
        if(nums.size() < k || k<=0)
            return r;
    	for (int i = 0; i < nums.size(); ++i) {
    		while(!dq.empty() && (nums[dq.back()]< nums[i])){
    		    dq.pop_back();//0
    		                    3 
    		}
    		dq.push_back(i);
    		if(dq.front() == i - k){//
    		    dq.pop_front();
    		}
    		if(i >= k -1){
    		    r.push_back(nums[dq.front()]);
    		}
    	}
    	return r;
    }
};
```