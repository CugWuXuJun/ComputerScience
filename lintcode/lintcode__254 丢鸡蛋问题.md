###[254.丢鸡蛋](#https://www.lintcode.com/problem/drop-eggs/description)
楼有 n 层高，鸡蛋若从 k 层或以上扔，就会碎。从 k 层以下扔，就不会碎。
现在给两个鸡蛋，用最少的扔的次数找到 k。返回最坏情况下次数。

样例
样例 1：

输入：100
输出：14
样例 2：

输入：10
输出：4
说明
对于 n = 10， 一种找 k 的初级方法是从 1、2 ... k 层不断找。但最坏情况下要扔 10 次。

注意有两个鸡蛋可以使用，所以可以从 4、7、9 层扔。这样最坏就只需要 4 次 (例如 k = 6 时)。


算法解析：设为了得到目标结果至少需要丢x次。设我们第一次丢鸡蛋的层数为第y层。  
（1）假设我们的鸡蛋在第y层破了，那么我们最坏的情况下需要检测y-1次，才能找到使得鸡蛋破碎的最低楼层。这个时候有 x = y   
（2）假设我们得鸡蛋仔第y层没有破，那么我们下次需要检测哪一层呢。延着（1）的思路，我们最坏情况下需要x次，这个时候，我们至多还有 x-1次检测的机会。假设我们下次检测的楼层的次数是z层，那么我们同样有两种情况分析，如果在第z层鸡蛋破了，我们需要检测的层数至多为 z - x - 1 = x - 2 那么有 z = 2x - 1 即我们检测的第二个楼层是2x - 1    
（3）由上面的规律可以看出来，我们需要检测的楼层符合的规律是这样的。   
   第一次： x    
	第二次： x + x-1 = 2x-1   
	第三次： x + x- 1 + x-2 = 3x -3   
	因而有下面的公式： x + x-1 + x-2 + x-3 +...+ 1 >= n
 	即 x^2 - x >=n
 代码如下：
 
 ```c++
 class Solution {
public:
    /**
     * @param n: An integer
     * @return: The sum of a and b
     */
    int dropEggs(int n) {
        // write your code here
        long long ans = 0;
        int x = 0;
        while (ans < n) {
            x += 1;
            ans += x;
        }
        return x;
    }
};
 ```
