#数据库的事务处理技术--故障恢复

##事务故障涉及到的主要问题
- 如何保证事务的原子性和持久性

##故障的种类
- 事务故障
   - 某一事务自身运行错误所引起的故障
   - 影响该事物本身。
- 系统故障
   - 由于掉电、非正常关机等所引起的故障
   - 影响正在运行的事务以及数据库缓冲区，数据库缓冲区将涉及正在运行和已经运行的事务。
- 介质故障
   - 由于介质损坏等所引起的故障
   - 影响是全面的，既影响内存中的数据，又影响介质中存储的数据。
##故障处理的宏观思路
###事务故障恢复
	事务故障可以通过重做事务（redo）以及撤销事务（undo）来恢复，重做事务可以保证已经提交事务的持久性，撤销事务则可以消除未提交事务的影响。
	
   撤销事务的使用：事务故障意味着事务没有到达预期的终点，因此数据库可能处于不正常的状态，恢复程序要在不影响其他事物运行的情况下，强行回滚该事物，即撤销事务已经做出的对任何数据库的修改，使得该事物好像没有启动一样，这类恢复操作称为事务撤销（undo）

### 系统故障
系统故障指的是造成系统停止运转的任何事件，使得系统要重新启动。例如，特定类型的硬件错误，操作系统故障、DBMS代码错误、系统断电、这类故障影响正在运行的所有事物，但是不破坏数据库，此时主存内容，尤其是数据库缓冲区（在内存）中的内容都被丢失，所有运行事务都非正常终止。发生系统故障的时候，一些尚未完成的事务的结果可能已送入物理数据库，从而造成数据库处于不正确的状态。为保证数据的一致性，需要清除这些事务对数据库的影响。  
恢复子系统必须在系统启动的时候让所有非正常终止的事务回滚，强行撤销所有未完成事务。  
另外一个方面，发生系统故障的时候，有些已经完成的事务可能有一部分升值全部都留在缓冲区，尚未写到磁盘上的物理数据库中，系统故障使得这些事务的数据库的修改部分或者全部丢失，这也会使得数据库处于不一致的状态，应该将这些事务已提交的结果重新写入数据库。所以系统重新启动后，恢复子系统除需要撤销所有未完成的事务外，还需要重做已经提交的事务，已将数据库恢复到一致状态。
恢复子系统必须在系统重新启动时让所有非正常终止的事务回滚，强行撤销所有未完成事务。
另一方面，发生系统故障时，有些已完成的事务可能有一部分升值全部留在缓冲区，尚未写回到物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失，这也使得数据库处于不一致的状态，因此应将这些事务已提交的结果写入数据库，所以系统重新启动后，恢复子系统除需要撤销所有未完成的事务外，还需要重做（redo）所有已经提交的事务，以将数据库真正恢复到一致状态。

- 系统故障恢复
 - 运行日志（System Log）
     - 运行日志是DBMS维护一个文件，该文件以流水方式记录了每一个事物对数据库的每一次操作及操作顺序。
     - 运行日志直接写入介质存储上，会保证正确性。
     - 当事务对数据库进行操作时：先写运行日志，写成功后，再与数据库缓冲区进行信息交换。
 - 系统故障可通过运行日志来恢复
     - 按照运行日志记录的事务操作顺序重做事务（当事务在发生故障的是已正确结束）或撤销事务（当事务在发生故障时未结束）
 - 但故障恢复是需要时间的
     - 运行日志保留了所甘甜的记录，当发生系统故障的时候应该从哪个时间点开始呢？
 
 - DBMS在运行日志中定期设置和更新检查点
      - 检查点是这样的时刻，在该时刻，DBMS强制使得内存DB Buffer中的内容与介质DB中的内容保持一致，即将DBbuffer更新的所有内容写入DB中。
      - 检查点表征了：在检查点之前内存中数据与介质中的数据是保持一致的。
 - 系统故障的恢复
      - 检查点之前结束的事务不需要恢复（已经写入DB）
      - 检查点之后结束或发生的事务需要依据运行日志进行恢复（不能确定是否写入DB），故障点前结束的重做，故障点时刻未结束的撤销。
 
- 介质故障恢复
 - 副本
      - 在任一时刻，对数据库在其他存储介质上产生的另一份等同记录
      - 用副本替换被破坏的数据库。
      - 由于介质故障的影响全面，在用副本恢复后还需要依据运行日志进行恢复
 - 这就涉及到什么时刻备份：转储点
      - 过频，影响系统工作效率；果疏，会造成运行日志过大，也影响系统运行性能。
      - 备份转储周期与运行日志的大小密切相关，应注意防止衔接不畅而一起
      
- 小结
  - 三种故障类型：事务故障、系统故障、介质故障
  - 三种恢复手段：事务的撤销与重做，运行日志与备份。
  - 三个重要时刻：检查点和转储点

##不同的缓冲区策略会影响事物的持久性
###缓冲区处理策略: 
 - force:内存中的数据最晚在commit的时候写入磁盘。  
 - No steal:不允许在事务commit之前把内存中的数据写入磁盘。  
 - No force:内存中的数据可以一直保留，在commit之后一段时间再写入磁盘。（此时在系统崩溃的时候可能还没写入到磁盘，需要redo） -- 灵活  
 - steal:允许在事务commit之前把内存中的数据写入磁盘。（此时若系统在commit之前崩溃时，已有数据写到磁盘中了，要恢复到崩溃前的状态，需要undo）
 当前最常用的方式是 steal + No force

##日志
 - 定义:
    - 一个包含日志记录的，只能追加的顺序文件，不同事物的日志记录交错存储，按发生时间存储。
 - undo日志(steal方法)
    - 对于任一事物T，按下列顺序向磁盘输出T的日志信息：
      - 首先,<T, X,v>被写到日志中
      - 其次，output(x)
      - 最后， <commit T> 或 <abort T>被写到日志中。
   - 注意： undo型日志仅保留旧值，<T,X,v>， v是原来的值。
   - undo型日志: "将事物改变的所有数据写到磁盘前不能提交该事物"。
 
 - 利用undo型日志进行恢复
  - 首先，确定每一个事物是否完成？
    - \<start T>... <commit> = yes
    - \<start T>... <abort> = no
    - \<start T>...    = no;
  - 然后，从日志的尾部开始按日志记录的反序，处理每一日志记录，撤销未完成事务的所有修改。
     - \<commit T> 标记T已经完成了
     - <abort T> 标记T已结束，但未完成
     - <T,X,v> 如果T未完成，则将X = v 写入磁盘，否则跳过。
     - <start T> :跳过
- redo日志
 - undo型日志的问题“将事务的改变写到磁盘之前是不能提交该事务”
 - 对于事务T，按下列顺序向磁盘中输出T的日志信息：
   - 首先：<T,X,v>被写到日志中
   - 其次：<commit T>被写入日志中
   - 最后：output（x）写入磁盘中
 - 注意：redo日志保留新的值。<T,X,v> v是更新后的值。
 - 注意：undo型日志，先输出，再commit 而redo 是先commit 再输出。
  - 利用redo进行恢复
 - 首先，确定每一个事物是否完成？
    - \<start T>... <commit> = yes
    - \<start T>... <abort> = no
    - \<start T>...    = no;
  - 然后，从日志的起始位置开始按日志记录的正序，处理每一日志记录，重做已经提交的事物。
     - \<commit T> 标记T已经完成了
     - <abort T> 标记T已结束，但未完成
     - <T,X,v> 如果T未完成，则将X = v 写入磁盘，否则跳过。
     - <start T> :跳过  
     - ##undo/redo日志     
 - 区别在于既要保留新值，也要保留旧值
 Undo/Redo型日志 - 对于任一事务T，按下列顺序向磁盘输出T的日志信息:  
    - 第(1)步，<T, X, u, v>被写到日志中 第(2)or(3)步，<COMMIT T>被写到日志中 
    - 第(3)or(2)步，OUTPUT(X)
 - undo/redo型日志既保留新值v，也保留旧值u。 注意:与undo型和redo型的差别，在后两步。Redo型是先写提交记录 后输出;undo型是先输出，再写提交记录;undo/redo型则无所谓谁先谁后，只要保证<T,X,u,v>被先于OUTPUT写完即可。
 
 - 利用undo/Redo型日志进行恢复   - 首先，确定每一个事务是否已完成？
      - <START T>....<COMMIT T>....    = yes 
      - <START T>....<ABORT T>....... = no(已结束，但未完成) 
      - <START T>........................... = no- 自前向后地，按日志记录的正序，重做所有已提交的事务;自后向前，按日志记录的反序，撤销所有未完成事务的所有修改。  - \<COMMIT T>:  标记T已完成  - \<ABORT T>:标记T已结束但未完成  - \<T,X,u,v>: 如果T未完成，则将X=u写回磁盘;否则将x=v写回磁盘; 
  - <START T>: 跳过
  上述过程泰国笼统了，需要仔细盘点。

##检查点（undo和redo都有可能，因此从前往后）
###为什么需要检查点（降低日志系统恢复的开销）
   - 当系统发生故障的时候，我们必须检查日志，决定哪些事务需要重做，哪些需要撤销，原则上，我们需要搜索整个日志确定该信息。这样做有两个主要的困难。
      - 搜索过程耗时
      - 大多数需要重做的事务已经把其更新操作写入了数据库中。尽管重做并不会造成不良后果，但是会使得恢复过程很漫长。
  - 为了降低这种开销，引入了检查点

###静止检查点
 - 特点：
   - 在执行检察点的过程中不允许任何更新
   - 在执行检察过程中将所有更新过的缓冲块都写到磁盘上。（数据库执行的过程中，先写日志，日志写完之后，在进行写磁盘的操作，写完之后，完成事务，再将commit 或者abort写入日志中。 这是采用的是steal方式。 如果在这个期间发生崩溃，需要undo）
- 执行过程
  - 将当前位于主存的所有日志记录输出到磁盘。
  - 将所有的修改的缓冲块输出到磁盘。
  - 将一个日志记录<checkpoint L> 输出到稳定存储器，其中L是执行检察点的时候正活跃的事务的列表。
  在检察点执行过程中，不允许事务的任何更新动作，如往缓冲块写入或者写日志记录。
  那么这样就可以实现预期的目的，在检察点之前的commit 和abort操作，都是已经不需要恢复和撤销的，在检察点之后的数据需要撤销或者重做。
- 恢复过程
  - 在恢复的过程中，需要从后往前找到第一个检察点之后进行恢复。
  
 
 - redo 为什么从前往后重做，而undo是从后往前做
 - redo 不断对数据库增加影响。undo是消除影响

