#数据库的事物处理技术（并发控制）
##三种典型的不一致现象
并发操作带来的数据不一致性包括丢失修改，不可重复读和读“脏”数据。
### 丢失修改  
   两个事物T1和T2读入同一个数据并修改，T2提交的结果破坏了T1提交的结果，导致了T1的修改被丢失。  
### 不可重复读
不可重复读是指事物T1读取数据后，事物T2执行更新操作，使T1无法再前一次读取结果。主要分三种，修改、增加数据，删除数据，后两种也被称之为幻读。  
### 读脏数据
读脏数据指的是事物T1读取了事物T2已经修改但是还没有提交的数据，一旦T2操作撤销，那么T1读取的数据就是无效的数据。

## 并发控制
并发操作破坏了事物的隔离性，并发控制就是要用正确的方式调度并发操作。使一个用户事物的执行不受其他食物的干扰，从而避免造成数据的不一致性。
并发控制的主要技术有封锁、时间戳、乐观控制法、和多版本并发控制等。

##事物调度与可串行性
###事物调度
- -组事物的基本步（读、写、其他控制操作如加锁、解锁）的一种执行顺序称为对这组事物的一个调度。   

### 并发调度
- 多个事物从宏观上是并行执行的，但是微观上基本操作则是交叉执行的。  

### 串行调度。   
- 属于同一个事物的不同操作连续先后执行，这样的调度称为串行调度。

### 并发调度的正确性
- 当且仅当这个并发调度下所得到的新数据库结果与分别串行地运行这些事物所得的新数据库完全一致，则说调度是正确的。
- 可串行性：如果不管数据库初始状态如何，一个调度度数据库状态的影响都和某个串行调度相同，则我们说这个调度是可串行话的或具有可串行性。
  - 可串行化调度一定是正确的调度，但是正确的调度，却未必是可串行话的调度。
  - 并行调度的正确性是指内容上结果正确行，而可串行性是指形式上和结果正确行，便于操作。
  - 可串行化的等效串行序列不一定唯一  

### 冲突可串行性
 - 冲突:调度中一对连续的操作，它们满足：如果它们的顺序交换，涉及的事物中至少有一个事物的行为会改变。
  - 有冲突的两个操作是不能交换次序的，没有冲突的两个事物是可以交换的。
  - 几种冲突的情况：
     - 同一事物的任何两个操作两个操作都是冲突的
     - 不同事物对同一元素的两个写操作是冲突的
     - 不同事物对同一元素的一读一写操作是冲突的
- 冲突可串行性 ：一个调度， 如果通过交换相邻两个无冲突的操作能够转换到某一个串行的调度，则此调度为
冲突可串行化的调度。（之前不理解的是所谓的串行化事物）
  - 冲突可串行性 是比 可串行性更严格的概念
  - 满足冲突可串行性，一定满足可串行性。   
    举例说明:
      - 可串行调度 但是不是冲突的，w1(Y); w2(Y);w2(X);w1(X); w3(X)；
      -  w1(Y); w1(X); w2(Y); w2(X); w3(X）  
   我们对这个结果是有异议的:视频上讲，因为最后都是由X对数据项进行修改，因此这个结果是不变的。加入我的X的属性是复合属性 比如说 （1，2，3），如果W2先把第二个数据改成为（1,4,3）,W2再把数据改成（1，5，3），最后w3 在修改第三个数据项，那么如果串行话执行的话，这个结果不一定是正确的，因而说这个
 可串行话调度的说法是错误的。
### 冲突可串行性判断算法
 - 问题  
 	并发调度的正确性：当且仅当这个并发调度所得到的新数据库结果与分别串行地运行这些事物所得到的新数据库完全一致，则说调度是正确的。
 - 冲突可串行性判别算法
 构造有向图，有冲突的先执行的事务指向后执行的事务，如果没有环，则是可串行化的。
 
## 基本封锁的并发控制方法
###常见锁
 - 排他锁：加了排他锁，其他事物不能再对其加锁。
 - 共享锁：加了共享锁，只能再加共享锁 不能加排他锁.
 
###三级加锁协议   
 - 一级封锁协议指的是指：事物T在修改数据R之前需要对其加X锁，直到事物结束才释放。事物结束包括正常结束和非正常结束。
      - 一级封锁协议可防止修改，并保证事物T是可恢复的。
      - 一级封锁协议中，如果仅仅是读取数据而不修改数据，是不需要加锁的，所以他不能保证可重复读，以及不能保证不读脏数据。
      - 对应的是读未提交
 - 二级封锁协议，在一级封锁协议的基础上增加对事务T在读取数据R之前，必须加S锁。读完就立即释放S锁
  	  - 二级封锁可以解决脏读的问题，由于读完数据就会释放S锁，那么它不能保证可重复读。
  	  - 对应的是读已提交。
 - 三级封锁协议，在一级封锁协议的基础上增加对事务T在读取数据R之前，必须加S锁。事务结束释放S锁。
 可以解决对值修改情况下的不可重复读，不能解决幻读。
     - 幻读的解决方法是范围锁、表锁
 
###两段封锁协议
- 读写数据之前要获得锁，每个事务中的所有封锁请求先于任何一个解锁请求。
- 两阶段：加锁段、解锁段。加锁段中不能有解锁，解锁段不能有加锁
	- 可能导致死锁。是冲突可串行性的
	- 延伸：如何解除死锁

##基于时间戳的并发控制方法
###时间戳
 - 时间戳：一种基于时间的标志，将某一时刻转换成的一个数值
 - 时间戳具有唯一性和递增性
 
###事务的时间戳
 - 事物T启动的时候，系统将此时刻赋予T，为T的时间戳
 - 时间戳可以表征一系列事物执行的先后次序，时间戳小的先执行，大的后执行
 - 利用时间戳，可以进行并发控制

###基于时间戳的并发控制
 - 时间戳方法给每一个事务盖上一个时标，即事务开始执行时间。每个事务具有唯一的时间戳，并按照这个时间戳来解决事务的冲突操作。如果发生冲突操作，就回滚具有较早时间戳的事务，以保证其他事务的正常执行，被回滚的事务被赋予新的时间戳并从头开始执行。
 - 借助时间戳，强制使一组并发事物的交叉执行，等价于一个特定顺序的串行执行
 - 特定顺序：时间戳从小到大
 - 如何强制：执行判断冲突
 	- 如无冲突：予以执行
 	- 如有冲突，则撤销事务，并重启该事务，此时该事务获得一个更大的时间戳，表明是后执行的任务。
 	- 有哪些冲突 ，读写冲突 写读冲突  写写冲突    

###基于时间戳的简单调度规则（时间戳排序协议）  
 - 对DB中的每一个数据元素x，系统保留其上最大的时间戳
   - RT(x) 成功读过该事务中的最大的时间戳，即最后读x的事务的时间戳。
   - WT(x) 成功写过该事务中的最大时间戳，即最后写x的事务的时间戳。  
 - 事务的时间戳 TS(T)  
 时间戳排序协议保证任何有read或者write操作按时间戳顺序执行，该协议的运作方式如下：
   - 假设事务T发出read(x)
      - 如果TS(x)大于等于写时间戳WT(x),那么表明写操作已经执行完毕，执行read（x）操作是没毛病的，然后将RT（x）时间戳修改成为 读时间戳RT（x）和事务时间戳TS（T）的时间戳的最大值。
      - 如果TS（x）小于写时间戳WT（x），则表示事务T想要读的x值已经被覆盖。因此读操作需要被回绝，事务回滚，重启事务（更新时间戳）
 - 假设事务发出写操作write（x）  
   - 如果TS(T)时间戳小于RT(x)时间戳，那么表明读操作已经完成，则事务T产生的x是先前所需要的值，且系统已经假定该值已经不会再产生，因此写操作会被回绝，事务回滚，重启事务。（更新时间戳）
   - 如果TS(T)时间戳小于写时间戳WT(x)，则T试图写入的Q值是过时的，因此，写操作被拒绝。事务回滚，重启事务。
   - 其他情况 事务执行write操作，将WT(x)赋予TS(T).  
  个人理解：事务的时间戳表明的是这个事务开始执行的时间。在这个事务开始后，其所代表的事务才能开始执行。
  
  
  - 这个算法可以解决的问题
   - 问题1：先启动的事务1 ，后启动的事务2  事务2在事务1之前执行了写 事务1之后执行了读（T过晚的读）
   - 问题2：先启动的事务1，后启动的事务2 事务2在事务1之前执行了写，事务1之后执行了写值（T过完的写）

 ### 还需要解决的问题
 - 脏读数据，如何放行一些可实现的冲突（过时的写操作可直接被忽略，而无需撤销过时的事务 - 托马斯写规则）。

## 基于有效性确认的并发控制的思想（乐观控制法）
- 基于有效性确认的并发控制方法任务事务很少发生冲突，因此不对事务进行特殊的管制，而是让他们自由执行，事务提交前再进行正确性检查。如果检查后发现该事物执行中出现过冲突并影响了可串行性，则拒绝提交并回滚该事务。

##多版本并发控制（MVCC）
   - 多版本并发控制指的是在数据库中通过维护数据对象的多个版本信息来实现高效并发控制的一种策略。 


 

  
      
  
 